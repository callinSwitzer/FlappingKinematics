---
title: "Bumblebee Flapping Kinematics Revision 1"
author: "Callin Switzer"
date: "August 19, 2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
# knitr setup
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```


---

### Measured variables:


- BeeID: Name given to an invididual (subscript in equations)
  (renamed as, "bee_ID" in analysis)
- order: This is the trial number per individual, either 1 or 2
- Treatment: Either light or heavy. H is with both nectar and external load, 
  L is just nectar load (subscript in equations)
  (Note: changed to "treatment" in analysis)
- Mstarved: The empty mass of the bee after being starved for days, 
  until it no longer buzzes when prodded in grams 
  (changed in analysis to mass_starved)
- M2: Total mass of the bee and load at beginning of trial in grams
  (changed to mass_0)
- MF: The mass of the bee and load at end of trial in grams
  (changed in analysis to mass_f)
- ITSpan = intertegular span in m
- S = area of both forewings in $m^2$
- metabolic_rate = Metabolic rate in mL $CO_2$ $hr^{-1}$
- freq = wing beat frequency in Hz
- amp = stroke amplitude of forewing in degrees
- wingLen = length of forewing from wing base to tip in meters
  (changed in analysis to wing_len)
 
---
 
### Calculated variables:


- avg_mass = (mass_0 + mass_f)/2 = the average mass of the 
  course of the trial
- load = avg_mass - mass_starved
- prec_load =  Percent load, %load (load/mass_starved)x100
- arc_len = (.75 $\cdotp$ wing_len) * (amp ($\pi$/180)) 	(amp is in degrees)
- wing_velocity = wing velocity (called "U" in paper) = arc_len$\cdotp$ freq $\cdotp$ 2   
  (the 2 comes from the fact that frequency consists of both an up and 
  down stroke, vel=∆x/∆t, ∆x=arclength, ∆t=1/(freg $\cdotp$ 2)
- force = $wing_velocity^2 \cdotp S$
- mass_spec_metabolic_rate = Mass specific metabolic rate. 
  (metabolic_rate / avg_mass)



---

## load packages and change global settings


```{r, message=FALSE, warning=FALSE}
# install packages
ipak <- function(pkg){
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if(length(new.pkg)) install.packages(new.pkg, dependencies = TRUE)
  sapply(pkg, require, character.only = TRUE)
}

packages <- c("roll", "lme4", "lmerTest", "influence.ME", "data.table", "tidyverse")
ipak(packages)

# set ggplot theme
theme_set(theme_classic() + 
            theme(axis.text=element_text(colour="black"), 
                  text=element_text(size=10)))

# set  directories
dataDir <- file.path(getwd(), "data")
figDir <- file.path(getwd(), "figures")
dataOut <- file.path(getwd(), "dataOutput")

print(paste("last run ", Sys.time()))
print(R.version)
```


### Import data


```{r}
raw_data <- read_csv(file.path(dataDir, "beeRespData_Revision1.csv"))
summary(raw_data)
```

---

# Data tidying

```{r}
# new frequency data
bdta <- raw_data %>%
  # rename variables
  rename(
         metabolic_rate = MetR, 
         mass_starved = Mstarved, 
         wing_len = wingLen, 
         mass_0 = M2,
         mass_f = MF, 
         IT_span = Itspan, 
         treatment = Treatment, 
         bee_ID  = BeeID, 
         freq = freq_audio # updated frequency data
         ) %>%
  # calculate new variables
  mutate(
     avg_mass = (mass_0 + mass_f)/2,
     load = avg_mass - mass_starved,
     perc_load = load / mass_starved * 100,
     arc_len = (0.75 *wing_len) * (amp * (pi / 180)),
     wing_velocity = arc_len * freq * 2,
     force = wing_velocity^2 * S,
     mass_spec_metabolic_rate = metabolic_rate / mass_starved,
     IT_span_mm = IT_span * 1000, 

     # convert to factor variables
     order = as.factor(as.character(order)),
     treatment = as.factor(as.character(treatment)),
     bee_ID = as.factor(as.character(bee_ID))
     )



# Create a new dataframe that calculates the changes for each individual bee
newDF <- data.frame()
colsTocalc = c("order", "mass_0", "mass_f", "metabolic_rate",
               "freq", "amp", "load", "avg_mass",
               "perc_load", "force", "wing_velocity", "arc_len")

for(varb in colsTocalc){
     data_wide <- data.table::dcast(bdta,
                                    bee_ID + mass_starved + S +
                                      IT_span + wing_len ~
                             treatment, value.var=c(varb))
     colnames(data_wide)[6:7] = paste(varb,
                                      colnames(data_wide)[6:7], sep = "_")
     if(varb == colsTocalc[1]){
       newDF <- data_wide
     }
     else newDF <- merge(newDF, data_wide, all.y = TRUE)    %>% as.tbl()
}

head(newDF)


# Calculate $\Delta$ variables
newDF <- newDF %>%
  mutate(
     delta_perc_load = perc_load_H - perc_load_L,
     avg_perc_load = (perc_load_H + perc_load_L) / 2,
     delta_metabolic_rate = metabolic_rate_H - metabolic_rate_L,
     delta_arc_len = arc_len_H - arc_len_L,

     # center delta load
     delta_load_centered = scale(load_H - load_L,
                       center = TRUE, scale = FALSE),
     delta_load_not_centered = load_H - load_L,
     delta_load_centered2 = delta_load_centered^2,
     delta_amp = amp_H - amp_L,
     delta_freq = freq_H - freq_L,
        
     IT_span_mm = IT_span*1000,

     # reformat order so that it is more interpretable
     order_1 = recode(.$order_H,
                      "2" = "loadedSecond",
                      "1" = "loadedFirst")
  
    )

```


```{r}
# corr for audio vs. video frequency data
plot(bdta$freq, bdta$freq_video)
abline(0,1)
cor(bdta$freq, bdta$freq_video)


```


---

# Modeling & Figure generation


## Metabolic Rate vs. loading conditions
## Fig 3a

```{r}
# calculate mean and SD
tapply(bdta$metabolic_rate, INDEX = bdta$treatment, 
       function(x) return(c(mean(x), sd(x))))


m1 <- lmer(metabolic_rate ~ treatment * I(scale(avg_mass)) + 
             (1|bee_ID), data = bdta)
summary(m1)

m2 <- update(m1, .~. - treatment:I(scale(avg_mass)))
anova(m2, m1, test = "LRT")


# model for paper with unscaled variables
m1 <- lmer(metabolic_rate ~ treatment * avg_mass + 
             (1|bee_ID), data = bdta)
summary(m1) # final model for paper

#######################################################
## Metabolic Rate vs. loading conditions
#######################################################

# predict lines from m2
# make dataset for Fig 3a
fig3a_dta <- bdta %>%
  mutate(HighLowTrt = recode(.$treatment, "H" = "Heavy load",
                       "L" = "Light load"),
         predictedmetabolic_rate = predict(m1, re.form = NA)) %>%
  select(avg_mass, HighLowTrt, metabolic_rate, predictedmetabolic_rate)


# save data
# write_csv(fig3a_dta, file.path(dataOut, "Fig3AData.csv"))



fig3a <- ggplot(fig3a_dta, aes(x = avg_mass, y = metabolic_rate )) +
  geom_point(aes(shape = HighLowTrt)) +
  geom_line(aes(y = predictedmetabolic_rate, color = HighLowTrt), size = 0.5) +
  labs(y = expression("Metabolic rate (mL CO" [2] %.% ~ "hr"^{-1}~ ")" ),
       x = "Total mass (g)") +
  lims(x = c(0.05,0.4), y = c(2, 18)) +
  theme(legend.title = element_blank(),
        legend.background = element_rect(colour = "black", size = 0.3),
        legend.position = c(0.8, 0.16),
        legend.text = element_text(size = 6),
        axis.text = element_text(size = 6),
        axis.title = element_text(size = 6),
        legend.key.size = unit(0.2, "cm")) +
  scale_color_grey() +
  scale_shape_manual(values = c(16,1))

fig3a

# ggsave(filename = file.path(figDir, "fig3A.png"), width = 6.5/2, height = 2,
#         plot = fig3a,
#        units = "in", dpi = 500)





# calculate R^2 for heavy
mod1 <- lm(metabolic_rate_H ~ I(mass_starved + load_H), data = newDF)

# diagnostics
par(mfrow = c(2,3))
plot(mod1, which = 1:6)
dev.off()
summary(mod1)

# R^2 for light
mod2 <-  lm(metabolic_rate_L ~ I(mass_starved + load_L), data = newDF)
summary(mod2)
# diagnostics
par(mfrow = c(2,3))
plot(mod2, which = 1:6)
dev.off()
```


## Mass-specific metabolic rate versus percent loading

```{r}
#######################################################
### Mass-specific metabolic rate versus percent loading
#######################################################

# Plot mass-specific metabolic rate vs. percent loading
noFig <- bdta %>%
  mutate(Trt2 = recode(.$treatment, "H" = "Heavy load",
                       "L" = "Light load")) %>%
ggplot(aes(x = perc_load, y = mass_spec_metabolic_rate )) +
  geom_point(aes(shape = Trt2)) +
  stat_smooth(aes(color = Trt2), method = "lm", se = F, size = 0.5) +
  labs(y = expression("Mass Specific Met. rate (mL CO"
                      [2] %.% ~ "hr"^{-1} %.% ~ "g"^{-1}~ ")" ),
       x = "Percent load") +
  #lims(x = c(0.05,0.4), y = c(2, 18)) +
  theme(legend.title = element_blank(),
        legend.background = element_rect(colour = "black", size = 0.3),
        legend.position = c(0.2, 0.8),
        legend.text = element_text(size = 6),
        axis.text = element_text(size = 6),
        axis.title = element_text(size = 6),
        legend.key.size = unit(0.2, "cm")) +
  scale_color_grey() +
  scale_shape_manual(values = c(16,1))
noFig


# ggsave(filename = file.path(figDir, "mass_spec_metabolic_rateate.png"), width = 6.5/2, height = 2,
#         plot = noFig,
#        units = "in", dpi = 500)


# calculate R^2 for heavy
mod1 <- lm(mass_spec_metabolic_rate ~ perc_load, data = bdta[bdta$treatment == "H", ])
# diagnostics
par(mfrow = c(2,3))
plot(mod1, which = 1:6)
dev.off()
summary(mod1)
with(bdta[bdta$treatment == "H", ], {
  plot(mass_spec_metabolic_rate ~ perc_load, pch = 20)
  lines(x = perc_load, y = predict(mod1))
})


mod2 <- lm(mass_spec_metabolic_rate ~ perc_load, data =  bdta[bdta$treatment == "L", ])
summary(mod2)
# diagnostics
par(mfrow = c(2,3))
plot(mod2, which = 1:6)
dev.off()

with(bdta[bdta$treatment == "L", ], {
  plot(mass_spec_metabolic_rate ~ perc_load)
  lines(x = perc_load, y = predict(mod2))
})

```


## Force vs. body mass
## Fig 3b

```{r}
m1 <- lmer((force) ~ treatment * I(scale(avg_mass)) + (1|bee_ID), data = bdta)
summary(m1)
car::vif(m1)
plot(m1)

# diagnostics
# qq plot
qqnorm(resid(m1), main = "")
qqline(resid(m1)) # good

# residual plot
plot(fitted(m1), resid(m1), xlab = "fitted", ylab = "residuals")
abline(0,0)

# QQPlot for group-level effects
qqnorm(ranef(m1)$bee_ID[[1]], main="Normal Q-Q plot for random effects")
qqline(ranef(m1)$bee_ID[[1]]) # looks good

infl <- influence(m1, obs = TRUE)
plot(infl, which = 'cook')

m2 <- update(m1, .~. - treatment : I(scale(avg_mass)))
anova(m2, m1, test = "LRT") 
summary(m2)


# treatment is not significant
m3 <- update(m2, .~. - treatment)
anova(m2, m3, test = "LRT")
summary(m3)

m3 <- update(m2, force ~ avg_mass + (1|bee_ID))
summary(m3) 

m4 <- update(m3, .~. - avg_mass)
anova(m3, m4, test = "LRT")


# Plot force vs. body mass + load
fig3b_dta <- bdta %>%
  mutate(Trt2 = recode(.$treatment, "H" = "Heavy load",
                       "L" = "Light load"))


# make dataset for Fig 3a
fig3b_dta <- bdta %>%
  mutate(HighLowTrt = recode(.$treatment, "H" = "Heavy load",
                       "L" = "Light load"),
         predictedTransForce = (predict(m3, re.form = NA))) %>%
  select(avg_mass, HighLowTrt, force, predictedTransForce)

# save data
#write_csv(fig3b_dta, file.path(dataOut, "Fig3BData.csv"))


fig3b <- ggplot(fig3b_dta, aes(x = avg_mass, y = force )) +
  geom_point(aes(shape = HighLowTrt)) +
  #stat_smooth(aes(color = HighLowTrt), method = "lm", se = F, size = 0.5) +
  geom_line(aes(y = predictedTransForce), color = "black", size = 0.5) +
  labs(y = expression("Translational force proxy (m"^4 %.% ~ "s"^{-2}~ ")" ),
       x = "Total mass (g)") +
  lims(x = c(0.05,0.4)) +
  theme(legend.title = element_blank(),
        legend.background = element_rect(colour = "black", size = 0.3),
        legend.position = c(0.8, 0.16),
        legend.text = element_text(size = 6),
        axis.text = element_text(size = 6),
        axis.title = element_text(size = 6),
        legend.key.size = unit(0.2, "cm")) +
  scale_color_grey() +
  scale_shape_manual(values = c(16,1)) +
  scale_y_continuous(labels = scales::scientific, limits = c(0, 5e-3))

fig3b

# ggsave(filename = file.path(figDir, "fig3B.png"), width = 6.5/2, height = 2,
#         plot = fig3b,
#        units = "in", dpi = 500)


# calculate R^2 for heavy
mod1 <- lm(force ~ avg_mass, data = bdta[bdta$treatment == "H", ])
# diagnostics
par(mfrow = c(2,3))
plot(mod1, which = 1:6)
dev.off()
(summ <- summary(mod1))
summ$r.squared

mod2 <- lm((force) ~ avg_mass, data =  bdta[bdta$treatment == "L", ])
summary(mod2)
summary(mod2)$r.squared
# diagnostics
par(mfrow = c(2,3))
plot(mod2, which = 1:6)
dev.off()

```


---

# Fig 4: Change in freq and amplitude

### 4a: Change in %load vs. change in amplitude

```{r}

# calculate mean and SD
tapply(bdta$amp, INDEX = bdta$treatment, 
       function(x) return(c(mean(x), sd(x))))

# fit full model
m1 <- lm(delta_amp ~  (I(scale(delta_perc_load)) +  I(scale(IT_span_mm)) + order_1)^2, data = newDF)
summary(m1)
car::vif(m1) # too high


# remove variables because of high VIF
m2 <- update(m1, .~. -  I(scale(IT_span_mm)):order_1)
car::vif(m2)
# now VIF is okay
summary(m2)

m3 <- update(m2, .~. - I(scale(delta_perc_load)):order_1)
summary(m3)
anova(m2, m3)


m4 <- update(m3, .~. - I(scale(delta_perc_load)):I(scale(IT_span_mm)))
anova(m3, m4)
summary(m4)

m5 <- update(m4, .~. - order_1)
anova(m4,m5)
summary(m5)
        
m6 <- update(m5, .~. -I(scale(IT_span_mm)) )
summary(m6) 
anova(m5, m6)


# final model for paper
m6 <- update(m6, .~ delta_perc_load)
summary(m6)

#write.table(as.data.frame(summary(m6)$coef),"clipboard",sep="\t")
 
# diagnostics
par(mfrow = c(2,3))
plot(m6, which = 1:6)
par(mfrow = c(1,1))

# Note that the t-stat^2 is the same as a partial f-test

### model visualization -- no need to use partial residuals, since 
### there is only one predictor



fig4a <- ggplot(newDF, aes(x= delta_perc_load, y = delta_amp)) +
  geom_point(shape = 17) +
  labs(x = "Δ % load", y = "Δ amplitude (deg)" ) +
  stat_smooth(method = 'lm', se = FALSE, color = "black", lty = 2, size = 0.5) +
  #scale_y_continuous(labels = scales::scientific, limits = c(-15, 25)) +
  theme(legend.title = element_blank(),
        legend.background = element_rect(colour = "black", size = 0.3),
        legend.position = c(0.8, 0.16),
        legend.text = element_text(size = 6),
        axis.text = element_text(size = 6),
        axis.title = element_text(size = 6),
        legend.key.size = unit(0.2, "cm"))
fig4a

# ggsave(filename = file.path(figDir, "fig4a.png"), width = 6.5/2, height = 2,
#         plot = fig4a,
#        units = "in", dpi = 500)


# calculate correlation coefficient
cor(newDF$delta_amp, newDF$delta_perc_load)**2


```


### change in freq vs. delta perc load

```{r}

# how many trials increased
newDF$FreqHigherInHeavy <- (newDF$freq_H - newDF$freq_L) > 0
summary(newDF$FreqHigherInHeavy)
sum(newDF$FreqHigherInHeavy) / nrow(newDF)

# which treatment did freq decline
tapply(newDF$FreqHigherInHeavy, INDEX = newDF$order_1, summary)

# calculate mean + sd for each treatment
tapply(bdta$freq, INDEX = bdta$treatment, function(x) c(mean(x), sd(x)))

# visualize data to see where bees decreased frequency
# ggplot(newDF, aes(y = delta_freq, x = order_1)) + 
#          geom_point(aes(color = delta_freq < 0)) + 
#   geom_text(aes(label=bee_ID),hjust=0.1, vjust=0, position= position_jitter()) 


# fit full model
m1 <- lm(delta_freq ~  (I(scale(delta_perc_load)) +  I(scale(IT_span_mm)) + order_1)^2, data = newDF)
summary(m1)
car::vif(m1) # too high


# remove variables because of high VIF
m2 <- update(m1, .~. - I(scale(IT_span_mm)):order_1)
car::vif(m2)
summary(m2)

m3 <- update(m2, .~. -I(scale(delta_perc_load)):order_1)
summary(m3)
anova(m2, m3)


m4 <- update(m3, .~. - I(scale(delta_perc_load)):I(scale(IT_span_mm)))
anova(m3, m4)
summary(m4)

m5 <- update(m4, .~. - I(scale(IT_span_mm)))
anova(m4,m5)
summary(m5)
        
m6 <- update(m5, .~. - I(scale(delta_perc_load)))
anova(m5, m6)
# final model for paper
summary(m6) 

anova(m6)
write.table(as.data.frame(round(summary(m6)$coef, 4)),"clipboard",sep="\t")



# diagnostics - the qq plot is a little thin tailed, 
# but I haven't found any transformations to help
par(mfrow = c(2,3))
plot(m6, which = 1:6)
par(mfrow = c(1,1))



### model visualization -- no need to use partial residuals, since 
### there is only one predictor

fig4b <- ggplot(newDF, aes(x= delta_perc_load, y = delta_freq)) +
  geom_point(aes(shape = order_1)) +
  labs(x = "Δ % load", y = "Δ freq (Hz)" ) +
  # stat_smooth(method = 'lm', se = FALSE, color = "black", lty = 2, size = 0.5) +
  # scale_y_continuous(labels = scales::scientific, limits = c(-15, 25)) +
  theme(legend.title = element_blank(),
        legend.background = element_rect(colour = "black", size = 0.3),
        legend.position = c(0.8, 0.16),
        legend.text = element_text(size = 6),
        axis.text = element_text(size = 6),
        axis.title = element_text(size = 6),
        legend.key.size = unit(0.2, "cm")) + 
  scale_shape_manual(values = c(17, 6))
fig4b



# ggsave(filename = file.path(figDir, "fig4b.png"), width = 6.5/2, height = 2,
#         plot = fig4b,
#        units = "in", dpi = 500)

# calculate correlation coefficients
cor(newDF$delta_freq, newDF$delta_perc_load)**2

```



---

# Fig 5


## 5a change in metabolic rate vs. change in amplitude

```{r}

# calculate correlations
cor(newDF$delta_metabolic_rate, newDF$delta_perc_load)**2
cor(newDF$delta_metabolic_rate, newDF$delta_amp)**2
cor(newDF$delta_metabolic_rate, newDF$delta_freq)**2

# correlation of log delta met rate
cor(log(newDF$delta_metabolic_rate), newDF$delta_freq)**2


mm1 <- lm(log(delta_metabolic_rate) ~  delta_amp + delta_freq +  
            delta_perc_load + IT_span_mm + order_1, data = newDF)
car::vif(mm1)
summary(mm1)



######################################################################
##  a priori decision to leave amp and freq in the model

mm2 <- update(mm1, .~. - delta_perc_load)
anova(mm1, mm2)
summary(mm2) 


mm3 <- update(mm2, .~. - order_1)
summary(mm3)
anova(mm3, mm2)

mm4 <- update(mm3, .~. - IT_span_mm)
summary(mm4) # final model for paper
anova(mm3, mm4)


write.table(as.data.frame(round(summary(mm4)$coef, 4)),"clipboard",sep="\t")


mm5 <- update(mm4, .~. - delta_amp)
anova(mm4, mm5)
summary(mm5)

par(mfrow = c(2,3))
plot(mm4, which = 1:6) # no glaring violations
par(mfrow = c(1,1))


### model visualization
fig5a <- ggplot(newDF, aes(x = delta_perc_load, y = delta_metabolic_rate)) +
  geom_point(aes(shape = order_1)) +
  labs(x = expression(Delta~" % load"),
       y = expression(Delta~"Metabolic Rate" )) +
  #stat_smooth(method = 'lm', se = FALSE, color = "black", lty = 2, size = 0.5) +
  #scale_y_continuous(limits = c(-2.5, 5)) +
  theme(legend.title = element_blank(),
        legend.background = element_rect(colour = "black", size = 0.3),
        legend.position = c(0.8, 0.16),
        legend.text = element_text(size = 6),
        axis.text = element_text(size = 6),
        axis.title = element_text(size = 6),
        legend.key.size = unit(0.2, "cm")) + 
  scale_shape_manual(values = c(6, 17))
fig5a

# ggsave(filename = file.path(figDir, "fig5a.png"), width = 6.5/2, height = 2,
#         plot = fig5a,
#        units = "in", dpi = 500)

fig5b <- ggplot(newDF, aes(x = delta_amp, y = delta_metabolic_rate)) +
  geom_point(aes(shape = order_1)) +
  labs(x = expression(Delta~" Amplitude (deg)"),
       y = expression(Delta~"Metabolic Rate" )) +
  #stat_smooth(method = 'lm', se = FALSE, color = "black", lty = 2, size = 0.5) +
  #scale_y_continuous(limits = c(-2.5, 5)) +
  theme(legend.title = element_blank(),
        legend.background = element_rect(colour = "black", size = 0.3),
        legend.position = c(0.8, 0.16),
        legend.text = element_text(size = 6),
        axis.text = element_text(size = 6),
        axis.title = element_text(size = 6),
        legend.key.size = unit(0.2, "cm")) + 
  scale_shape_manual(values = c(6, 17))
fig5b

# ggsave(filename = file.path(figDir, "fig5b.png"), width = 6.5/2, height = 2,
#         plot = fig5b,
#        units = "in", dpi = 500)



fig5c <- ggplot(newDF, aes(x = delta_freq, y = delta_metabolic_rate)) +
  geom_point(aes(shape = order_1)) +
  labs(x = expression(Delta~" frequencey (Hz)"),
       y = expression(Delta~"Metabolic Rate" )) +
    geom_line(aes( x = delta_freq, y = exp(predict(mm5)))) + 
  #stat_smooth(method = 'lm', se = FALSE, color = "black", lty = 2, size = 0.5) +
  #scale_y_continuous(limits = c(-2.5, 5)) +
  theme(legend.title = element_blank(),
        legend.background = element_rect(colour = "black", size = 0.3),
        legend.position = c(0.8, 0.16),
        legend.text = element_text(size = 6),
        axis.text = element_text(size = 6),
        axis.title = element_text(size = 6),
        legend.key.size = unit(0.2, "cm")) + 
  scale_shape_manual(values = c(6, 17))
fig5c

library(scales)

fig5c + 
  scale_y_continuous(trans="log",breaks = trans_breaks("log", function(x) exp(x)),
                labels = trans_format("log", math_format(e^.x)))

# ggsave(filename = file.path(figDir, "fig5c.png"), width = 6.5/2, height = 2,
#         plot = fig5c,
#        units = "in", dpi = 500)

```


# Figure 6
# delta metabolic rate / delta percent load

```{r}

# calculate new variables
newDF <- newDF %>%
  mutate(avg_perc_load = (perc_load_H + perc_load_L) / 2, 
         dmr_dpl = delta_metabolic_rate / delta_perc_load, 
         damp_dpl = delta_amp / delta_perc_load, 
         dfreq_dpl = delta_freq / delta_perc_load)


mod1 <- lm(dmr_dpl  ~ avg_perc_load + order_1 + IT_span_mm, data = newDF)
summary(mod1)

mod2 <- update(mod1, .~. - IT_span_mm)
anova(mod1, mod2) 
summary(mod2)

mod3 <- update(mod2, .~. - order_1)
anova(mod2, mod3) 

summary(mod3) # final model for paper

# calculate R^2 values
with(newDF, cor(dmr_dpl, avg_perc_load)**2)
with(newDF, cor(damp_dpl, avg_perc_load)**2)
with(newDF, cor(dfreq_dpl, avg_perc_load)**2)


cor(newDF$delta_load_not_centered, newDF$IT_span)**2
cor(newDF$delta_perc_load, newDF$IT_span)**2

with(bdta[bdta$treatment == "H",], cor(amp, freq)**2)
with(bdta[bdta$treatment == "L",], cor(amp, freq)**2)

with(bdta[bdta$treatment == "L",], plot(amp, freq))

cor(newDF$delta_amp, newDF$delta_freq)**2

ggplot(newDF, aes(y = delta_amp, x = delta_freq)) + 
  geom_point(aes(color = order_1))


```


### Signal processing examples

```{r}

## signal processing functions

fft_calculator = function(timeSignal, log_rate){
    # calculate fft
    n = length(timeSignal)
    Y = fft(timeSignal)/n
    amplitudeAndPhase = Y[(1:(n/2))]*2 # these are complex numbers
    
    # calculate fft frequencies
    k = 0:n
    Ts = n/log_rate
    frq = k/Ts # two side frequency range
    frq = frq[1:(n/2)] # one side frequency range
    
    return(list('amplitudeAndPhase' = amplitudeAndPhase, "frq" =  frq))
}

minmaxScale <- function(x){
    return((((x- min(x, na.rm = TRUE)) /(max(x, na.rm = TRUE)-min(x, na.rm = TRUE))) - 0.5)*2)
}
  
shifter <- function(x, n = 1) {
  if (n == 0) x else c(tail(x, -n), head(x, n))
}




# rolling variance example
# works on "missing fundamental" signals

xx = seq(0, 1, length.out = 1000)
b = sin(2*pi*40*xx) + sin(2*pi*50*xx) + sin(2*pi*60*xx) + sin(2*pi*70*xx) + sin(2*pi*80*xx) + sin(2*pi*90*xx) +
  sin(2*pi*100*xx)+ sin(2*pi*110*xx)+ sin(2*pi*120*xx)+ sin(2*pi*130*xx)+ sin(2*pi*140*xx) + rnorm(1000, sd = 0.1)

b = shifter(b, n = 50)

par(mfrow =c(2,2))
plot(xx, b, type = 'l', main = "unprocessed, spiky signal", xlab = "time (s)", ylab = "unprocessed signal")

gaussianWindow = dnorm(seq(-4, 4, length.out = length(xx)))
gaussianWindow = gaussianWindow*(1/max(gaussianWindow))

fft_data = fft_calculator(gaussianWindow*b, 1000)


amplitudeAndPhase = fft_data[["amplitudeAndPhase"]]
frq = fft_data[["frq"]]

plot(abs(amplitudeAndPhase), x = frq, type = "l", xlab = "freq (Hz)", 
     ylab = "relative amplitude", main = "DFT spectrum of unprocessed, spiky signal", xlim = c(0, 200), yaxt = "none")



# rolling variance
roll_window = 50

rollingVar = roll_var(as.matrix(b), width = roll_window, center = TRUE)
rollingVar = shifter(rollingVar, n = roll_window/2)
rollingVar = minmaxScale(rollingVar)
rollingVar[is.na(rollingVar)] = 0

plot(xx,rollingVar,  type = 'l', main = "rolling variance of original signal", xlab = "time (s)")

fft_data = fft_calculator(gaussianWindow*rollingVar - mean(gaussianWindow*rollingVar), 1000)

amplitudeAndPhase = fft_data[["amplitudeAndPhase"]]
frq = fft_data[["frq"]]

plot(abs(amplitudeAndPhase), x = frq, type = "l", xlab = "freq (Hz)", 
     ylab = "relative amplitude", main = "DFT spectrum of rolling variance signal", xlim = c(0, 200), yaxt = "none")


### here's another example that's more similar to the 
### audio data we have

xx = seq(0, 1, length.out = 10000)
amp = sin(2*pi*xx*5)
b = amp* rnorm(length(xx), sd = 0.3)



par(mfrow =c(2,2))
plot(xx, b, type = 'l', main = "unprocessed, spiky signal", xlab = "time (s)", ylab = "unprocessed signal")
gaussianWindow = dnorm(seq(-4, 4, length.out = length(xx)))
gaussianWindow = gaussianWindow*(1/max(gaussianWindow))

fft_data = fft_calculator(gaussianWindow*b, length(xx))


amplitudeAndPhase = fft_data[["amplitudeAndPhase"]]
frq = fft_data[["frq"]]

plot(abs(amplitudeAndPhase), x = frq, type = "l", xlab = "freq (Hz)", 
     ylab = "relative amplitude", main = "DFT spectrum of unprocessed, spiky signal", xlim = c(0, 200), yaxt = "none")

roll_window = 500

rollingVar = roll_var(as.matrix(b), width = roll_window, center = TRUE)
rollingVar = shifter(rollingVar, n = roll_window/2)
rollingVar = minmaxScale(rollingVar)
rollingVar[is.na(rollingVar)] = 0


plot(xx,rollingVar,  type = 'l', main = "rolling variance of original signal", xlab = "time (s)")

fft_data = fft_calculator(gaussianWindow*(rollingVar), length(xx))

amplitudeAndPhase = fft_data[["amplitudeAndPhase"]]
frq = fft_data[["frq"]]

plot(abs(amplitudeAndPhase), x = frq, type = "l", xlab = "freq (Hz)", 
     ylab = "relative amplitude", main = "DFT spectrum of rolling variance signal", xlim = c(0, 200), yaxt = "none")


```


# Session Info
```{r}
sessionInfo()

Sys.time()

```